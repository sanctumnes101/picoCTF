## Description

> The image link appears broken... https://jupiter.challenges.picoctf.org/problem/17205 or http://jupiter.challenges.picoctf.org:17205


## Hints

> This is only a JavaScript problem.


## Approach & Solution

First of all let's head to the website. We say that there is a text input and a button. Let's try random input and hit `Submit`. We got a broken image. By reading the description we conclude that we have to see the actual image to get the flag.

Let's see what's happening we hit the `Submit` button by analyzing the source code.

The source code of the page:

```

<html>
	<head>    
		<script src="jquery-3.3.1.min.js"></script>
		<script>
			var bytes = [];
			$.get("bytes", function(resp) {
				bytes = Array.from(resp.split(" "), x => Number(x));
			});

			function assemble_png(u_in){
				var LEN = 16;
				var key = "0000000000000000";
				var shifter;
				if(u_in.length == LEN){
					key = u_in;
				}
				var result = [];
				for(var i = 0; i < LEN; i++){
					shifter = key.charCodeAt(i) - 48;
					for(var j = 0; j < (bytes.length / LEN); j ++){
						result[(j * LEN) + i] = bytes[(((j + shifter) * LEN) % bytes.length) + i]
					}
				}
				while(result[result.length-1] == 0){
					result = result.slice(0,result.length-1);
				}
				document.getElementById("Area").src = "data:image/png;base64," + btoa(String.fromCharCode.apply(null, new Uint8Array(result)));
				return false;
			}
		</script>
	</head>
	<body>

		<center>
			<form action="#" onsubmit="assemble_png(document.getElementById('user_in').value)">
				<input type="text" id="user_in">
				<input type="submit" value="Submit">
			</form>
			<img id="Area" src=""/>
		</center>

	</body>
</html>

```

Focusing on the `center` tags at the end of the source code, we see that when we hit submit, we're sending the input we wrote down in the text box to a function called `assemble_png` and it's input is the input we wrote in the text box.

So from now on, we need to analyze the `assemble_png` function:

+ before the function itself, an array called `bytes` is created and filled with values from `$/bytes`. $ in the current directory so `$/bytes` is: https://jupiter.challenges.picoctf.org/problem/17205/bytes

+ var LEN = 16;  === defining a variable called `LEN` with a value of `16`

+ var key = "0000000000000000";  === defining a variable called `key` with a value of `0000000000000000`

+ var shifter;  === defining a variable called `shifter` with unassigned value

+	if(u_in.length == LEN){  === if the `u_in`, which is the user's text input that we wrote in the text box, length is `16`, then change `key` value to the user's input
			key = u_in;
		}
    
+ var result = [];  === defining an empty array called `result`

+ for(var i = 0; i < LEN; i++){  === iterating 16 times

+			shifter = key.charCodeAt(i) - 48;  === assigning the number value of the char in index `i` to the variable `shifter`, for example char `'0'` becomes number `0`.

+			for(var j = 0; j < (bytes.length / LEN); j ++){  === iterating (bytes.length / 16) times == 720/16 times == 45 times

+   			result\[(j * LEN) + i\] = bytes\[(((j + shifter) * LEN) % bytes.length) + i\];  === doing some kind of encryption by shifting values  			
 			
+ The while loop: It slices zeros at the end of the result

+ document.getElementById("Area").src = "data:image/png;base64," + btoa(String.fromCharCode.apply(null, new Uint8Array(result)));  === creating the encrypted(Base 64) image source


What we notice is filling 16*45 indexes in `result` array. Instead of looking at `result` as a 1D array, we can look at it as a 2D array with 16 columns and 45 rows. Notice that `result` gets filled with `bytes` value using some kind of shifting.
We have to find the `shifter` values which are the user input.

Every image can be hex dumped, which means we can see it's hex values. So let's convert the `bytes` decimal ASCII values to the corresponding hex values using an online [decimal to hex](https://www.rapidtables.com/convert/number/ascii-hex-bin-dec-converter.html) converter.

I'm using [HxD](https://mh-nexus.de/en/hxd/) hex editor, so let's create a new file in `HxD`, right click and `paste-insert` the hex strings we got before.
As you can see, there is 16 columns and 45 rows. The main problem is, how will we find the `shifter` values?

An important note to know, for each file type, there is a header hex values in the beginning of file that must be present to know the file type.
For `png` images, it starts with an 8bytes signature, and then the first chunk is the `IHDR` chunk, which is 13bytes long. For more information: [https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header](https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header).
So we know what the first 21 bytes must be. We only care about the first 16 bytes, since the `shifter` gets it's value from the `key` variable that is 16 chars long.

Ok so, shifter gets it value 16 times, and we know the first 16 bytes of the png file from the wikipedia article above. So to get the `shifter` values using this information, we will look at:

result\[0\], result\[1\], ... , result\[15\], which are the png header hex values that we know:

+ result\[0\]= 89 ===> possible `shifter` value at index 0 by looking at offset in HxD: 5
+ result\[1\]= 50 ===> possible `shifter` value at index 1 by looking at offset in HxD: 1
+ result\[2\]= 4E ===> possible `shifter` value at index 2 by looking at offset in HxD: 0
+ result\[3\]= 47 ===> possible `shifter` value at index 3 by looking at offset in HxD: 8
+ result\[4\]= 0D ===> possible `shifter` value at index 4 by looking at offset in HxD: 1
+ result\[5\]= 0A ===> possible `shifter` value at index 5 by looking at offset in HxD: 8
+ result\[6\]= 1A ===> possible `shifter` value at index 6 by looking at offset in HxD: 0
+ result\[7\]= 0A ===> possible `shifter` value at index 7 by looking at offset in HxD: 3
+ result\[8\]= 00 ===> possible `shifter` value at index 8 by looking at offset in HxD: 2,3,4
+ result\[9\]= 00 ===> possible `shifter` value at index 9 by looking at offset in HxD: 3,4,5,6
+ result\[10\]= 00 ===> possible `shifter` value at index 10 by looking at offset in HxD: 2,3,4
+ result\[11\]= 0D ===> possible `shifter` value at index 11 by looking at offset in HxD: 6
+ result\[12\]= 49 ===> possible `shifter` value at index 12 by looking at offset in HxD: 3
+ result\[13\]= 48 ===> possible `shifter` value at index 13 by looking at offset in HxD: 6
+ result\[14\]= 44 ===> possible `shifter` value at index 14 by looking at offset in HxD: 4
+ result\[15\]= 52 ===> possible `shifter` value at index 15 by looking at offset in HxD: 0

Since we have difference possibilities for indexes 8,9 and 10, we have to brute force the key using the possibilities of the indexes(most of them are certain!).

After brute forcing, they key that gets us an image is: `5108180345363640`. We got a QR png image!

Steps to continue:

+ Download the QR image (.png!)
+ Decode the QR code online using [this site](https://zxing.org/w/decode.jspx) (or google one yourself!)
+ Get the flag: `picoCTF{066cad9e69c5c7e5d2784185c0feb30b}`


## Final Answer

`picoCTF{066cad9e69c5c7e5d2784185c0feb30b}`









